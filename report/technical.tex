\section{Technical Details}
\label{sec:technical}
Most of the approaches of my project is adapted from huang et al.\cite{huang2019aideme} dual space method (DSM).
\subsection{Data Space}
With the bundling process, different OTF2 traces are being parsed and loaded in the Traveler. The trace file I worked with was generated from a fibonacci
calculation of size 23 on phylanx system. The contents of a OTF2 trace data can be printed using \emph{otf2-print} command and read using \emph{less}
\cite{kerrisk2010linux} on unix environment from the root directory of the project.
\begin{verbatim}
    otf2-print data/20190906-lra-t16/OTF2_archive/\
    APEX.otf2 | less -S
\end{verbatim}
Figure.~\ref{fig:sample_otf2} represents a sample print of the {OTF2} trace data. This sample data has been used in this milestone to study and test
different components of traveler-integrated project. In this trace file, each row contains the following attributes:
\begin{itemize}
    \item Event (Categorical) : \{{ENTER, LEAVE, METRIC}\}, Indicating the arrival {(ENTER)} and departure {(LEAVE)} event of a particular primitive and
    relevant metric {(METRIC)} values for the preceding rows event.
    \item Location (Categorical) : The hardware core number starting from 1,2,\ldots, etc. - where the actual processing executed.
    \item Timestamp (Quantitative) : Actual temporal data in nanoseconds.
    \item Additional Attributes : This column contains some additional categorical attributes like {GUID}; parent {GUID}; primitive name; metric id, name,
    value, etc.
\end{itemize}
%
\begin{figure}[h]
    \centering
    \includegraphics[width=3.5in]{figs/otf2_sample.png}
    \caption{Sample print of the {OTF2} trace data}
    \label{fig:sample_otf2}
\end{figure}
%
In the frontend of the Traveler platform, when user comes to browse the dataset, a time series chart is presented for the performance metric data ({METRIC}
values in the OTF2) as Figure.~\ref{fig:papi_tot_cyc1}.

\begin{figure}[h]
    \centering
    \includegraphics[width=3.5in]{figs/papi_loc1.PNG}
    \caption{CPU cycle rate}
    \label{fig:papi_tot_cyc1}
\end{figure}
Here, the x-axis represents time in milliseconds and y-axis represents corresponding metric rate ({PAPI\_TOT\_CYC} in Figure.\ref{fig:papi_tot_cyc1}). For
{PAPI\_TOT\_CYC}, the corresponding value is monotinically increamental data. Let, at CPU thread location $l$, $X^l_j$ be the value for leave event at
timestamp $T^l_j$, $X^l_i$ be the value for enter event at timestamp $T^l_i$, then the metric rate for CPU thread $l$ is,
\[
    r^l_j = \dfrac{abs(X_j-X_i)}{T_j-T_i}
\]
Here, the value for $r^l_j$ is plotted on y-axis for time value $T^l_j$.
\par
Therefore, for all CPU thread location $l \in L$, the set of rate at particular time $i$ is $R_i = \{r^l_i\}, l = 1, \dots L$. This can be projected as a
tuple which is mapped on a $L$-dimensional space. The resulting data space is where the user exploration will take place. This has been used as input feature
set for the recommender model.
%
%
\subsection{Initial data labeling} A user feedback is incorporated with the tuple as a output label from the set $\{-1, 0,1\}$, where $1$ depicts interesting,
$-1$ being not interesting and $0$ represents unlabeled by the user. This can help to bootstrap the data exploration. If it is not possible to collect user
feedback, the system can run initial sampling described in \cite{liu2018analysis}\cite{dimitriadou2014explore}, or use some statistical measurements. During
my training phase, as I didn't have access to collect user feedback, I used standard deviation with certain threshold to label the data tuples.
%
%
\subsection{Active Learning}
To dynamically find the next tuple for labeling, I used Support Vector Machine (SVM)\cite{suykens1999least} as a classification model. The unlabeled samples
can be labeled with the prediction of the {SVM}. Here, uncertainties are measured by the distance of each example from the decision boundary of the SVM. More
description about the usage of the classifier can be found in\cite{huang2019aideme}.
%
%
\subsection{Convergence Algorithm}
The convergence algorithm utilizes the dual space model described in \cite{huang2018optimization}. Here, to update the positive region, convex hull of the
positive example points are used and checked if it is inside the hull. For the negative example, I checked if it is outside the convex hull generated from
the negative example points. Although huang et al. used convex cone generated by the conical combination of the vectors from the positive example to the
given negative example. The reason behind this is that, the outside region of a convex hull can eliminate regions more faster than the conve cone (since it
covers more area than the convex cone).